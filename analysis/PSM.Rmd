---
title: "Airbnb: Causal Inference"
subtitle: "Inferring Causal Effects of Marketing Ads on User Bookings"
author: "Diana Liang, Andrew Pagtakhan"
date: "12/4/2020"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
    number_section: true
---

```{r setup, include=TRUE, message=FALSE, warning=FALSE}

library(knitr)
library(tidyverse)
library(here)
library(gridExtra)
library(rpart)
library(ranger)
library(MatchIt)
library(arm)
library(gbm)
library(BART)
library(correlationfunnel)
library(conflicted)

conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")

# set seed
seed <- 14
set.seed(seed)

# increase memory limit for matching functions
# make sure this limit is compatible with the system used to run this code
memory.limit(3.2e10)

knitr::opts_chunk$set(echo = TRUE, 
                      tidy.opts=list(width.cutoff=60), 
                      tidy=TRUE,
                      warning = FALSE,
                      message = FALSE,
                      cache.lazy = FALSE)
```

Load data
```{r load_data}
# read in data
dat <- read_csv(here::here('data', 'bookings_sample.csv'))

# convert categorical variables
dat <- dat %>% mutate_at(vars(c("gender","browser_group")),as.factor)

# Airbnb color palette (for plotting)
# Source: https://usbrandcolors.com/airbnb-colors/
col.pal <- c("#FC642D", "#00A699", "#FF5A5F", "#767676", "#484848")
treat.labs <- c("Indirect Ad", "Direct Ad")
treat.name <- "Treatment"
```

# Exploratory Data Analysis and Overlap

There is sufficient overlap for the covariates between those who received 
direct marketing ads vs. indirect ads.

See Tableau workbook: 
https://public.tableau.com/profile/andrew.pagtakhan#!/vizhome/NYU_Causal_Airbnb/Dashboard?publish=yes

Note: Underlying data used for Tableau workbook is ```bookings_sample.csv```

# Modeling
## Logistic Regression

```{r log_reg, cache = TRUE}
# fit model
fit.lr <- glm(treat~is_eng+is_mobile+age+gender+browser_group,
              family=binomial,
              data=dat)

# extract propensity scores
dat$pscores.lr <- predict(fit.lr,type='response')

## one-to-one nearest neighbor w/ replacement
matches.lr <- matching(z=dat$treat,score=dat$pscores.lr,replace=T)
weight.lr <- ifelse(dat$treat==0,matches.lr$cnts,1)

## IPTW
dat$IPTW.lr <- dat %>% 
  transmute(IPTW=if_else(treat==1,1,pscores.lr/(1-pscores.lr))) %>% 
  unlist() %>% 
  unname()
```


## Probit Regression
```{r prob_reg, cache = TRUE}
# fit model
fit.prob <- glm(treat~is_eng+is_mobile+age+gender+browser_group,
                family=binomial(link='probit'),
                data=dat)

# extract propensity scores
dat$pscores.prob <- predict(fit.prob,type='response')

## one-to-one nearest neighbor w/ replacement
matches.prob <- matching(z=dat$treat,score=dat$pscores.prob,replace=T)
weight.prob <- ifelse(dat$treat==0,matches.prob$cnts,1)

## IPTW
dat$IPTW.prob <- dat %>% 
  transmute(IPTW=ifelse(treat==1,1,pscores.prob/(1-pscores.prob))) %>% 
  unlist() %>% 
  unname()
```

## CART
```{r cart, cache = TRUE}
# fit model
fit.cart <- rpart(treat~is_eng+is_mobile+age+gender+browser_group,
                  data=dat,
                  method='class') # fit a CART model

# extract p scores
# take probability of assigned=1 as propensity scores
dat$pscores.cart <- predict(fit.cart,type='prob')[,2]

## one-to-one nearest neighbor w/ replacement
matches.cart <- matching(z=dat$treat,score=dat$pscores.cart,replace=T)
weight.cart <- ifelse(dat$treat==0,matches.cart$cnts,1)

## IPTW
dat$IPTW.cart <- dat %>% 
  transmute(IPTW=ifelse(treat==1,1,pscores.cart/(1-pscores.cart))) %>% 
  unlist() %>% 
  unname()
```


## Random Forest
```{r rf, cache = TRUE}
fit.rf <- ranger(treat~is_eng+is_mobile+age+gender+browser_group,
                 data=dat)

dat$pscores.rf <- predict(fit.rf,data=dat)$predictions

## one-to-one nearest neighbor w/ replacement
matches.rf <- matching(z=dat$treat,score=dat$pscores.rf,replace=T)
weight.rf <- ifelse(dat$treat==0,matches.rf$cnts,1)

## IPTW
dat$IPTW.rf <- dat %>% 
  transmute(IPTW=ifelse(treat==1,1,pscores.rf/(1-pscores.rf))) %>% 
  unlist() %>% 
  unname()
```

## GBM
```{r gbm, cache = TRUE, message=FALSE}
fit.gbm <- gbm(treat~is_eng+is_mobile+age+gender+browser_group,
               data=dat,
               distribution = "bernoulli")

dat$pscores.gbm <- predict(fit.gbm)

## one-to-one nearest neighbor w/ replacement
matches.gbm <- matching(z=dat$treat,score=dat$pscores.gbm,replace=T)
weight.gbm <- ifelse(dat$treat==0,matches.gbm$cnts,1)

## IPTW
dat$IPTW.gbm <- dat %>% 
  transmute(IPTW=ifelse(treat==1,1,pscores.gbm/(1-pscores.gbm))) %>% 
  unlist() %>% 
  unname()
```

## BART
```{r bart, cache = TRUE}
# run BART on sample data due to computational time
bart_sample <- 1000
book_sample <- sample_n(dat, bart_sample)

# get covariates for model
xtrain_bart <- as.data.frame(book_sample %>% 
                               select(age, gender, treat, is_mobile, 
                                      browser_group, is_eng))
# run predictions on all data
xtest_bart <- as.data.frame(dat %>% 
                                select(age, gender, treat, is_mobile, 
                                      browser_group, is_eng))
# fit and predict
bart <- gbart(x.train = xtrain_bart,  
              y.train = book_sample$treat,
              x.test = xtest_bart,
              printevery = FALSE,
              type = "lbart",
              seed = seed,
              mc.cores = 2)

# add prop scores on full dataset
dat$pscores.bart <- bart$prob.test.mean

## one-to-one nearest neighbor w/ replacement
matches.bart <- matching(z=dat$treat,score=dat$pscores.bart,replace=T)
weight.bart <- ifelse(dat$treat==0,matches.bart$cnts,1)

## IPTW
dat$IPTW.bart <- dat %>% 
  transmute(IPTW=ifelse(treat==1,1,pscores.bart/(1-pscores.bart))) %>% 
  unlist() %>% 
  unname()
```



# Model Summaries

## Propensity Scores
```{r prop_scores}
# plot propensity scores
dat %>% 
  pivot_longer(cols = contains("pscores")) %>% 
  ggplot(aes(x = value, fill = as.factor(treat))) + 
  geom_histogram(alpha = 0.5) + 
  facet_wrap(facets = vars(name), scales = "free") + 
  labs(title = "Propensity Score Distributions") + 
  theme(legend.position = "bottom") +
  scale_fill_manual(name = treat.name,
                    labels = treat.labs,
                    values = col.pal)
```


## Balance

```{r balance_rev, message=FALSE}
# recode categorical
cat <- dat %>% select(gender,browser_group) %>% binarize()
dat_bal <- bind_cols(dat,cat)

# get covariates and convert to matrices for balance function
bal_mat <- as.matrix(dat_bal %>% select(c(contains(c("browser", "gender")), 
                                      -c("gender", "browser_group","first_browser"),
                                      c("age", "is_mobile", "is_eng"))))
bal_treat <- as.matrix(dat_bal$treat)

# matched weights
match_counts <- list(matches.lr$cnts, dat$IPTW.lr,
                     matches.prob$cnts, dat$IPTW.prob,
                     matches.cart$cnts, dat$IPTW.cart,
                     matches.rf$cnts, dat$IPTW.rf,
                     matches.gbm$cnts, dat$IPTW.gbm,
                     matches.bart$cnts, dat$IPTW.bart)

# convert to matrices
match_mat <- lapply(match_counts, as.matrix)

# compute balance statistics for each model
bal_list <- lapply(match_mat, 
                   function(x) {
                     balance(rawdata = bal_mat, 
                             treat = bal_treat,
                             matched = x,
                             estimand = "ATT")$diff.means.matched
                   })

# model names
model_list <- c('LR 1-1NN','LR IPTW',
                 'PR 1-1NN','PR IPTW',
                 'CART 1-1NN','CART IPTW',
                 'RF 1-1NN','RF IPTW',
                 'GBM 1-1NN','GBM IPTW',
                 'BART 1-1NN','BART IPTW')

# add model name column
bal_dfs <- list()
for (i in 1:length(bal_list)) {
    bal_df <- as.data.frame(bal_list[[i]]) %>% 
      rownames_to_column(var = "Covariate")
    bal_df$model_name <- model_list[[i]]
    bal_dfs[[i]] <- bal_df
}

# add pre-matched balance metrics
bal_df_pre <- as.data.frame(balance(rawdata = bal_mat, 
                                    treat = bal_treat, 
                                    # placeholder - not used
                                    matched = match_counts[[1]], 
                                    estimand = "ATT")$diff.means.raw) %>% 
              rownames_to_column(var = "Covariate")
# add model name
bal_df_pre$model_name <- "prematch"


# combine balance metrics
bal_df <- rbind(bal_df_pre, bind_rows(bal_dfs))

# plot
p.md <- ggplot(bal_df, aes(x = model_name, y = Covariate)) + 
        geom_tile(aes(fill = abs.std.diff)) + 
        labs(title = "Balance: Standardized Difference in Means") + 
        scale_fill_gradient(low = "#ffd9dc", high = "#FF5A5F") + 
        theme(axis.text.x=element_text(angle=45,vjust=.6))

p.sd <- ggplot(bal_df, aes(x = model_name, y = Covariate)) + 
        geom_tile(aes(fill = ratio)) + 
        labs(title = "Balance: SD Ratios") +  
        scale_fill_gradient(low = "#ffd9dc", high = "#FF5A5F") + 
        theme(axis.text.x=element_text(angle=45,vjust=.6))
p.md
#grid.arrange(p.md, p.sd, nrow = 2)
```

```{r}
# best model based on difference in means
kable(bal_df %>% 
  group_by(model_name) %>% 
  summarise(mean.bal = mean(abs.std.diff)) %>% 
  arrange(mean.bal), 
  caption = "Absolute Standardized Difference in Means")
```

```{r, include=FALSE, eval=FALSE}
# ratio
kable(bal_df %>% 
  filter(Covariate == "age") %>%
  group_by(model_name) %>% 
  summarise(rat = mean(ratio)) %>% 
  arrange(rat),
  caption = "Standard Deviation Ratios")
```


```{r balance, eval = FALSE, include=FALSE}
# recode categorical
cat <- dat %>% select(gender,browser_group) %>% binarize()
dat <- bind_cols(dat,cat)

# covariate list
cov <- c('is_eng','is_mobile','age',names(cat))

# examine balance
check_balance <- function(data,covariates,weights){
  out <- list()
  for(cov in covariates){
    prematch_mean_trt <- sapply(data[data$treat==1,cov],mean)
    prematch_mean_ctr <- sapply(data[data$treat==0,cov],mean)
    matched_mean_trt <- weighted.mean(t(data[data$treat==1,cov]),weights[data$treat==1])
    matched_mean_ctr <- weighted.mean(t(data[data$treat==0,cov]),weights[data$treat==0])
    prematch_mean_diff <- ifelse(n_distinct(data[,cov])==2,prematch_mean_trt-prematch_mean_ctr,(prematch_mean_trt-prematch_mean_ctr)/sapply(data[data$treat==1,cov],sd))
    matched_mean_diff <- ifelse(n_distinct(data[,cov])==2,matched_mean_trt-matched_mean_ctr,(matched_mean_trt-matched_mean_ctr)/sapply(data[data$treat==1,cov],sd))
    prematch_sd_r <- sapply(data[data$treat==0,cov],sd)/sapply(data[data$treat==1,cov],sd)
    matched_sd_r <- sqrt(wtd.var(t(data[data$treat==0,cov]),weights[data$treat==0]))/sqrt(wtd.var(t(data[data$treat==1,cov]),weights[data$treat==1]))
    # format output as one df for each cov
    out[[cov]] <- tibble(cov,prematch_mean_diff,matched_mean_diff,prematch_sd_r,matched_sd_r)
    out[[cov]] <- tibble(cov=rep(cov,4),
                         metrics=rep(c('SMD','VR'),each=2),
                         matched=rep(c('prematch','matched'),2),
                         values=c(prematch_mean_diff,matched_mean_diff,prematch_sd_r,matched_sd_r))
  }
  out_df <- bind_rows(out)
  return(out_df)
}

# check balance for each method
balance_lr.nn <- check_balance(dat,cov,weight.lr) %>% mutate(method='LR 1-1NN')
balance_lr.IPTW <- check_balance(dat,cov,dat$IPTW.lr) %>% mutate(method='LR IPTW')
balance_prob.nn <- check_balance(dat,cov,weight.prob) %>% mutate(method='PR 1-1NN')
balance_prob.IPTW <- check_balance(dat,cov,dat$IPTW.prob) %>% mutate(method='PR IPTW')
balance_cart.nn <- check_balance(dat,cov,weight.cart) %>% mutate(method='CART 1-1NN')
balance_cart.IPTW <- check_balance(dat,cov,dat$IPTW.cart) %>% mutate(method='CART IPTW')
balance_rf.nn <- check_balance(dat,cov,weight.rf) %>% mutate(method='RF 1-1NN')
balance_rf.IPTW <- check_balance(dat,cov,dat$IPTW.rf) %>% mutate(method='RF IPTW')
balance_gbm.nn <- check_balance(dat,cov,weight.gbm) %>% mutate(method='GBM 1-1NN')
balance_gbm.IPTW <- check_balance(dat,cov,dat$IPTW.gbm) %>% mutate(method='GBM IPTW')
balance_bart.nn <- check_balance(dat,cov,weight.bart) %>% mutate(method='BART 1-1NN')
balance_bart.IPTW <- check_balance(dat,cov,dat$IPTW.bart) %>% mutate(method='BART IPTW')

# store prematch values
dat_prematch <- balance_lr.nn %>% 
  filter(matched=='prematch') %>% 
  mutate(method='prematch') %>% 
  select(-matched)
# store matched values under different method
dat_balance <- bind_rows(balance_lr.nn,balance_lr.IPTW,balance_prob.nn,balance_prob.IPTW,balance_cart.nn,balance_cart.IPTW,balance_rf.nn,balance_rf.IPTW,balance_gbm.nn,balance_gbm.IPTW,balance_bart.nn,balance_bart.IPTW) %>%
  filter(matched=='matched') %>%
  select(-matched) %>%
  bind_rows(dat_prematch) %>%
  mutate(method=factor(method,levels=c('prematch','LR 1-1NN','LR IPTW','PR 1-1NN','PR IPTW','CART 1-1NN','CART IPTW','RF 1-1NN','RF IPTW','GBM 1-1NN','GBM IPTW','BART 1-1NN','BART IPTW')))

# display balance
## difference in means
dat_balance %>% filter(metrics=='SMD') %>%
  ggplot(aes(method,cov,fill=values)) +
  geom_tile() +
  theme(axis.text.x=element_text(angle=45,vjust=.6)) +
  ylab('covariates') +
  ggtitle('Standardized Difference in Means')
## ratios of standard deviations
dat_balance %>% filter(metrics=='VR') %>%
  ggplot(aes(method,cov,fill=values)) +
  geom_tile() +
  theme(axis.text.x=element_text(angle=45,vjust=.6)) +
  ylab('covariates') +
  ggtitle('Ratios of Standard Deviations')
```

# Estimate Causal Effects

The best model based on balance metrics is [X]


# Estimate Causal Effects

## Treatment Effect for Best Model

Based on the balance metrics, the Probit Regression using IPTW Matching 
was the best model.
```{r}
# logistic regression to get final treatment effect
model_fin <- glm(is_booked ~ is_eng + is_mobile + age + 
                             gender + browser_group + treat, 
              family = quasibinomial(link = "logit"),
              data = dat,
              weights = dat$IPTW.prob)

# odds
odds <- exp(model_fin$coefficients["treat"][[1]])
# probability
paste0("Treatment Effect: ", prob_treat <- odds / (1 + odds))
```

## Treatment effect for all models
```{r}
# treatment effect for all models
effects_list <- lapply(match_counts, 
                       function(x) {
                         glm(is_booked ~ is_eng + is_mobile + age + 
                             gender + browser_group + treat, 
                             family = quasibinomial(link = "logit"),
                             data = dat,
                             weights = x) 
                         }
                       )
```

